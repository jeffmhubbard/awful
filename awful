#!/usr/bin/env bash

# Awful Lock Screen
# Blur + Vignette Lock Screen using i3lock-color and FFmpeg
#
# extbin: ffmpeg i3lock xrandr xdpyinfo

APPNAME='awful'
VERSION='0.1'

# Paths
USER_CONF="$HOME/.config/awful/config"
CACHE_DIR="$HOME/.cache/awful"
IMG_CACHE="$CACHE_DIR/lockscreen.png"
IMG_CAP="$CACHE_DIR/capture.png"

# Defaults
barcolor=ffffff19
typingcolor=00ff0080
deletecolor=ffff0080
authcolor=00ffff80
errorcolor=ff000080
textcolor=ffffffe6
subtextcolor=ffffff80
font="sans-serif"
textsize=64
subtextsize=24
greetertext="Welcome"
timetext="%l:%M%p"
datetext="%A, %b %e, %Y"
mesgcolor=ffffffff
mesgfont="sans-serif"
mesgsize=16
authmesg="Verifying..."
errormesg="Access Denied"
lockmesg="Locking..."
failedmesg="Lock Failed"
inputmesg="Enter Password..."
stepper=10
screen=0
span=false

# Load config file
if [ -e "$USER_CONF" ]; then
    source "$USER_CONF"
fi

# Create cache directory
mkdir -p "$CACHE_DIR"

# Get list of displays
get_display_list () {
    local num=0
    mapfile -t active < <( xrandr --listactivemonitors )
    for monitor in "${active[@]:1}"; do
        (( num++ ))
        local monitor=$(echo $monitor | sed -r 's/\/[0-9]*//g')
        local info=( $monitor )
        DISP_LIST+=("$num ${info[3]} ${info[2]}")
    done
}

# Get total combined display resolution
get_total_size () {
    TOTAL_SIZE=$(xdpyinfo | grep -w "dimensions" | sed -r 's/^[^0-9]*([0-9]+x[0-9]+).*$/\1/')
}

# Pass through path if file, or return random if dir
get_image_path() {
    local path="$1"
    if [ ! -d "$path" ]; then
        IMG_CACHE="$path"
        return
    fi
    local dir=("$path"/*)
    dir="${dir[RANDOM % ${#dir[@]}]}"
    get_image_path "$dir"
}

# Cache image with scaled to resolution with effects
cache_image () {
    local user_img=$1
    local resx="${2%%x*}"
    local resy="${2##*x}"
    local out=$3
    local scale="$resx:$resy:force_original_aspect_ratio=increase,crop=$resx:$resy"
    ffmpeg -loglevel -8 -y \
        -i "$user_img" \
        -vf "scale=$scale, boxblur=3:1, vignette=angle=PI/4" \
        "$out"
    echo "Caching $(basename "$user_img") @ ${resx}x${resy}"
}

# make blue canvas
make_canvas () {
    local out=$1
    echo "Creating canvas @ $TOTAL_SIZE..."
    ffmpeg \
        -loglevel -8 -y \
        -f lavfi \
        -i "color=blue:$TOTAL_SIZE" \
        "$out"
}

# Compose lockscreen image from per-resolution versions
compose_image () {
    local user_img=$1
    local canvas="${CACHE_DIR}/canvas.png"
    local clean_tmp=( ${canvas} )
    local dcnt=( ${#DISP_LIST[*]} )

    make_canvas "$canvas"

    for DISP in "${DISP_LIST[@]}"; do
        disp=( $DISP )

        local num="${disp[0]}"
        local name="${disp[1]}"
        local geo="${disp[2]##* }"
        local res="${geo%%+*}"
        local pos="${geo#*+}"
        local tmp_img="${CACHE_DIR}/${name}.png"

        cache_image "$user_img" "$res" "$tmp_img"

        file_args="$file_args -i $tmp_img"
        # shellcheck disable=SC1087
        if [ "${dcnt[*]}" -gt "$num" ]; then
            filter_args="$filter_args[${num}:v]overlay=${pos%%+*}:${pos##*+}[v${num}];[v${num}]"
        else
            filter_args="$filter_args[$num:v]overlay=${pos%%+*}:${pos##*+}[output]"
        fi

        clean_tmp+=( ${tmp_img} )
    done

    # compose lockscreen image
    echo "Merging temp files..."
    ffmpeg -i ${canvas} ${file_args} \
        -loglevel -8 -y \
        -filter_complex "[0:v]${filter_args}" \
        -map [output]:v \
        -pix_fmt rgb24 \
        "$IMG_CACHE"

    echo "Cleaning up..."
    rm ${clean_tmp[*]}
}

# Update cached image
update () {
    echo "Updating cache..."
    local img_path=$1
    # purge previous image
    [[ -e $IMG_CACHE ]] && rm "$IMG_CACHE"

    get_display_list
    get_total_size
    DNUM=${#DISP_LIST[*]}

    echo "Displays: $DNUM    Size: $TOTAL_SIZE    Span: $span"

    if [ "$span" = true ] || [ "$DNUM" = 1 ]; then
        cache_image "$img_path" "$TOTAL_SIZE" "$IMG_CACHE"
    else
        compose_image "$img_path"
    fi

    [[ -e $IMG_CACHE ]] && echo "Done!"
}

# Cache screen capture with effects
cache_capture () {
    ffmpeg -loglevel -8 -y \
        -f x11grab -framerate 1 \
        -video_size "$TOTAL_SIZE" \
        -i :0.0 -vframes 1 \
        -vf "boxblur=3:1, vignette=angle=PI/4" \
        "$IMG_CAP"
    echo "Caching screen capture..."
}

# Capture screen shot
capture () {
    cache_capture
    [[ -e $IMG_CAP ]] && echo "Done!"
}

prelock() {
    # pause dunst
    if [ -n "$(pidof dunst)" ]; then
        pkill -u "$USER" -USR1 dunst
    fi
}

# Run after unlocking
postlock() {
    # remove capture
    [[ -e "$IMG_CAP" ]] && rm "$IMG_CAP"
    # unpause dunst
    if [ -n "$(pidof dunst)" ] ; then
        pkill -u "$USER" -USR2 dunst
    fi
}

# Wrap i3lock
lock () {
    echo "Locking..."
    local LOCK_IMG=$1

    local totalx="${TOTAL_SIZE%%x*}"
    local totaly="${TOTAL_SIZE##*x}"
    if [ $screen -lt 1 ]; then
        local width=$((totalx/DNUM))
        local height=$((totaly))
    else
        local geo=${DISP_LIST[$((screen-1))]##* }
        local res=${geo%%+*}
        local width=${res%%x*}
        local height=${res##*x}
    fi

    # allow position time\date on second display
    if [[ $span = true ]]; then
        rightpos=$totalx
    else
        rightpos=$width
    fi

    prelock

    i3lock \
        --screen "$screen" \
        --image="$LOCK_IMG" \
        --bar-indicator \
        --bar-position="$height" --bar-direction 1 \
        --bar-width "$width" --bar-orientation=horizontal \
        --bar-max-height=28 \
        --bar-step="$stepper" --bar-periodic-step="$stepper"*2 \
        --bar-color="$barcolor" \
        --keyhlcolor="$typingcolor" --bshlcolor="$deletecolor" \
        --ringvercolor="$authcolor" --ringwrongcolor="$errorcolor" \
        --timestr="$timetext" --force-clock \
        --timepos x+"$rightpos"-30:"$height"-80 --time-align 2 \
        --timecolor="$textcolor" --time-font="$font" --timesize="$textsize" \
        --datestr="$datetext" \
        --datepos x+"$rightpos"-30:"$height"-45 --date-align 2 \
        --datecolor="$subtextcolor" --date-font="$font" --datesize="$subtextsize" \
        --greetertext="$greetertext" \
        --greeterpos x+30:"$height"-80 --greeter-align 1 \
        --greetercolor="$textcolor" --greeter-font="$font" --greetersize="$textsize" \
        --keylayout 0 \
        --layoutpos x+30:"$height"-45 --layout-align 1 \
        --layoutcolor="$subtextcolor" --layout-font="$font" --layoutsize="$subtextsize" \
        --veriftext="$authmesg" \
        --verifpos x+10:"$height"-6 --verif-align 1 \
        --verifcolor="$mesgcolor" --verif-font="$mesgfont" --verifsize="$mesgsize" \
        --wrongtext="$errormesg" \
        --wrongpos x+10:"$height"-6 --wrong-align 1 \
        --wrongcolor="$mesgcolor" --wrong-font="$mesgfont" --wrongsize="$mesgsize" \
        --modifpos x+"$width"-10:"$height"-6 --modif-align 2 \
        --statuspos x+10:"$height"-6 \
        --locktext="$lockmesg" --lockfailedtext="$failedmesg" \
        --noinputtext="$inputmesg" \
        --show-failed-attempts --ignore-empty-password \
        --redraw-thread ${lockargs}

    postlock
}

# Lock screen
lock_select () {
    get_display_list
    get_total_size
    DNUM=${#DISP_LIST[*]}

    echo "Displays: $DNUM    Size: $TOTAL_SIZE    Span: $span"

    case "$1" in
        lock)
            # use cached wallpaper
            lock "$IMG_CACHE"
            ;;
        capture)
            # use screen capture
            capture
            lock "$IMG_CAP"
            ;;
    esac
}

# Help message
usage() {
    echo
    echo " $APPNAME $VERSION"
    echo
    echo "  -u --update"
    echo "      Update lock screen image"
    echo "      $ $APPNAME -u PATH"
    echo
    echo "  -l --lock"
    echo "      Lock screen with cached image"
    echo "      $ $APPNAME -l"
    echo
    echo "  -c --capture"
    echo "      Capture screen and lock"
    echo "      $ $APPNAME -c"
    echo
    echo "  -s --suspend"
    echo "      Lock screen and suspend system"
    echo "      $ $APPNAME -s"
    echo
    exit 1
}

# No arguments
[[ "$1" = '' ]] && usage

# Parse arguments
for arg in "$@"; do
    [[ "${arg:0:1}" = '-' ]] || continue
    case "$1" in
        -h | --help)
            usage
            break
            ;;
        -s | --suspend)
            runsuspend=true
            ;&
        -l | --lock)
            runlock=true
            [[ $runsuspend ]] || lockargs="$lockargs --nofork"
            ;;
        -c | --capture)
            runcap=true
            [[ $runsuspend ]] || lockargs="$lockargs --nofork"
            ;;
        -u | --update)
            runupdate=true
            argpath="$2"
            ;;
        --)
            lockargs="$lockargs ${@:2}"
            break
            ;;
        *)
            echo "unknown argument: $1"
            break
            ;;
    esac
done

[[ $runupdate ]] && update "$argpath"

[[ $runlock ]] && lock_select lock && \
    { [[ $runsuspend ]] && systemctl suspend; }

[[ $runcap ]] && lock_select capture && \
    { [[ $runsuspend ]] && systemctl suspend; }


exit 0

# vim: ft=sh:
